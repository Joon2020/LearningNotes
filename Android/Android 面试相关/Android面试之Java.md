# Java

| 时间       | 版本  | 说明           |
| ---------- | ----- | -------------- |
| 2020.10.15 | 0.0.1 | 初创，结构输入 |
|            |       |                |

## 基础

### 一、Object

#### 1. 两个值相等的 Integer 对象，== 比较，判断是否相等

Integer对象值的范围为 `[-128 - 127]` 时，不会创建新的引用，指向同一个地址，地址值相等。

但是当超过这个范围后，就会 new 一个对象，引用指向的地址是不同的，地址值不相等。

#### 2. 下面的代码，再次使用对象 student 是否需要判空？

> **Java 中方法参数的使用情况总结：**
>
> - 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）；
> - 一个方法可以改变一个对象参数的状态；
> - 一个方法不能让对象参数引用一个新的对象

```csharp
public void test()  {
    Student student = new Student("Bobo", 15);
    changeValue1(student);   // student值未改变，不为null! 输出结果 student值为 name:Bobo、age:15
    // changeValue2(student);  // student值被改变，输出结果 student值为 name:Lily、age:20
    System.out.println("student值为 name: " + student.name + "、age:" + student.age);
}

public static void changeValue1(Student student) {
    student = null;
}

public static void changeValue2(Student student)  {    
     student.name = "Lily";    
     student.age = 20;
}
```

#### 3. equals和==的区别？equals和hashcode的关系？

- ==：基本类型比较值，引用类型比较地址。
- `equals`：默认情况下，`equals`作为对象中的方法，比较的是地址，不过可以根据业务，修改`equals`方法。

`equals`和`hashcode`之间的关系：

默认情况下，`equals`相等，`hashcode`必相等，`hashcode`相等，`equals`不是必相等。hashcode基于内存地址计算得出，可能会相等，虽然几率微乎其微。



### 二、String

#### 1. 下面的代码， str 值最终为多少？换成 Integer 值又为多少，是否会被改变？

> - **考点**：Java 值传递 (第 2 题相同)。编写代码测试，在 changeValue() 方法中修改入参，并**不会改变**之前的值；
> - **原理** ：[Java 程序设计语言总是采用按值调用](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJavaGuide%2Fblob%2Fmaster%2Fdocs%2Fessential-content-for-interview%2FPreparingForInterview%2F%E5%BA%94%E5%B1%8A%E7%94%9F%E9%9D%A2%E8%AF%95%E6%9C%80%E7%88%B1%E9%97%AE%E7%9A%84%E5%87%A0%E9%81%93Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98.md%23%E4%B8%80-%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92)，方法得到的是所有参数值的一个拷贝，即方法**不能修改**传递给它的任何参数变量的内容。基本类型参数传递的是参数副本，对象类型参数传递的是**对象地址的副本；**
> - **题解**：在 changeValue() 中，对于对象类型参数，直接修改的是**对象地址副本**的值，所以之前变量的地址并未被修改！若修改的是对象实例里面的某个值，之前变量则会被修改



```rust
public void test() {
    String str = "123";
    changeValue(str); 
    System.out.println("str值为: " + str);  // str未被改变，str = "123"
}

public changeValue(String str) {
    str = "abc";
}
```

#### 2. String、StringBuffer和StringBuilder的区别？

- `String`：`String`属于不可变对象，每次修改都会生成新的对象。
- `StringBuilder`：可变对象，非多线程安全。
- `StringBuffer`：可变对象，多线程安全。

大部分情况下，效率是：`StringBuilder`>`StmiandringBuffer`>`String`。

### 三、继承

#### 1. Java中抽象类和接口的特点？

共同点：

- 抽象类和接口都不能生成具体的实例。
- 都是作为上层使用。

不同点：

- 抽象类可以有属性和成员方法，接口不可以。
- 一个类只能继承一个类，但是可以实现多个接口。
- **抽象类中的变量是普通变量，接口中的变量是静态变量。**
- 抽象类表达的是`is-a`的关系，接口表达的是`like-a`的关系。

#### 2. 关于多态的理解？

多态是面向对象的三大特性：继承、封装和多态之一。

多态的定义：允许不同类对同一消息做出响应。

多态存在的条件：

1. 要有继承。
2. 要有复写。
3. 父类引用指向子类对象。

Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中的方法重载。




### 四、注解
### 五、序列化
### 六、集合

#### 1. Java 集合，介绍下ArrayList 和 HashMap 的使用场景，底层实现原理

#### 2. ArrayList 与 LinkedList 的区别

#### 3. HashMap的特点是什么？HashMap的原理？

HashMap的特点：

1. 基于Map接口，存放键值对。
2. 允许key/value为空。
3. 非多线程安全。
4. 不保证有序，也不保证使用的过程中顺序不会改变。

简单来讲，核心是**数组+链表/红黑树**，HashMap的原理就是存键值对的时候：

1. 通过键的Hash值确定数组的位置。
2. 找到以后，如果该位置无节点，直接存放。
3. 该位置有节点即位置发生冲突，遍历该节点以及后续的节点，比较`key`值，相等则覆盖。
4. 没有就新增节点，默认使用链表，相连节点数超过8的时候，在jdk 1.8中会变成红黑树。
5. 如果Hashmap中的数组使用情况超过一定比例，就会扩容，默认扩容两倍。

当然这是存入的过程，其他过程可以自行查阅。这里需要注意的是：

- `key`的hash值计算过程是高16位不变，低16位和高16位取异或，让更多位参与进来，可以有效的减少碰撞的发生。
- 初始数组容量为16，默认不超过的比例为0.75。

### 七、泛型

#### 1. 说一下对泛型的理解？

泛型的本质是**参数化类型，在不创建新的类型的情况下，通过泛型指定不同的类型来控制形参具体限制的类型**。也就是说在泛型的使用中，操作的数据类型被指定为一个参数，这种参数可以被用在类、接口和方法中，分别被称为泛型类、泛型接口和泛型方法。

泛型是Java中的一种语法糖，能够在代码编写的时候起到类型检测的作用，但是虚拟机是不支持这些语法的。

泛型的优点：

1. 类型安全，避免类型的强转。
2. 提高了代码的可读性，不必要等到运行的时候才去强制转换。

#### 什么是类型擦除？

不管泛型的类型传入哪一种类型实参，对于Java来说，都会被当成同一类处理，在内存中也只占用一块空间。通俗一点来说，就是泛型只作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的信息擦除，也就是说，成功编译过后的class文件是不包含任何泛型信息的。



### 八、反射机制

#### 1. 动态代理和静态代理

静态代理很简单，运用的就是代理模式：

![代理模式](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a6cfb98cfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



声明一个接口，再分别实现一个真实的主题类和代理主题类，通过让代理类持有真实主题类，从而控制用户对真实主题的访问。

动态代理指的是在运行时动态生成代理类，即代理类的字节码在运行时生成并载入当前的ClassLoader。

动态代理的原理是使用反射，思路和上面的一致。

使用动态代理的好处：

1. 不需要为`RealSubject`写一个形式完全一样的代理类。
2. 使用一些动态代理的方法可以在运行时制定代理类的逻辑，从而提升系统的灵活性。




### 九、IO
### 十、深拷贝和浅拷贝

### 十一、其他

## 并发
### 一、线程

#### 1. 线程的状态有哪些？

线程的状态有：

- `new`：新创建的线程
- `Ready`：准备就绪的线程，由于CPU分配的时间片的关系，此时的任务不在执行过程中。
- `Running`：正在执行的任务
- `Block`：被阻塞的任务
- `Time Waiting`：计时等待的任务
- `Terminated`：终止的任务

附上一张状态转换的图：

![线程状态转换](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a6f77cf96c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 2. 线程中wait和sleep的区别？

`wait`方法既释放cpu，又释放锁。 `sleep`方法只释放cpu，但是不释放锁。

#### 3. 线程和进程的区别？

线程是CPU调度的最小单位，一个进程中可以包含多个线程，在Android中，一个进程通常是一个App，App中会有一个主线程，主线程可以用来操作界面元素，如果有耗时的操作，必须开启子线程执行，不然会出现ANR，除此以外，进程间的数据是独立的，线程间的数据可以共享。



### 二、线程池

#### 1. 说下对线程池的理解，以及创建线程池的几个关键参数

线程池的构造函数如下：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
	this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
}
```

参数解释如下：

- `corePoolSize`：核心线程数量，不会释放。
- `maximumPoolSize`：允许使用的最大线程池数量，非核心线程数量，闲置时会释放。
- `keepAliveTime`：闲置线程允许的最大闲置时间。
- `unit`：闲置时间的单位。
- `workQueue`：阻塞队列，不同的阻塞队列有不同的特性。

线程池分为四个类型：

- `CachedThreadPool`：闲置线程超时会释放，没有闲置线程的情况下，每次都会创建新的线程。
- `FixedThreadPool`：线程池只能存放指定数量的线程池，线程不会释放，可重复利用。
- `SingleThreadExecutor`：单线程的线程池。
- `ScheduledThreadPool`：可定时和重复执行的线程池。



#### 2. 与新建一个线程相比，线程池的特点？

1. 节省开销： 线程池中的线程可以重复利用。
2. 速度快：任务来了就能开始，省去创建线程的时间。
3. 线程可控：线程数量可空和任务可控。
4. 功能强大：可以定时和重复执行任务。

#### 3. 线程池的工作流程？



![线程池工作流程](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a7092b526a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

简而言之：

1. 任务来了，优先考虑核心线程。
2. 核心线程满了，进入阻塞队列。
3. 阻塞队列满了，考虑非核心线程（图上好像少了这个过程）。
4. 非核心线程满了，再触发拒绝任务。



### 三、锁

#### 1. 死锁触发的四大条件？

- 互斥锁

- 请求与保持

- 不可剥夺

- 循环的请求与等待

#### 2. synchronized关键字的使用？synchronized的参数放入对象和Class有什么区别？

synchronized 修饰 static 方法、普通方法、类、方法块区别？

`synchronized`关键字的用法：

- 修饰方法
- 修饰代码块：需要自己提供锁对象，锁对象包括对象本身、对象的Class和其他对象。

放入对象和Class的区别是：

1. 锁住的对象不同：成员方法锁住的实例对象，静态方法锁住的是Class。
2. 访问控制不同：如果锁住的是实例，只会针对同一个对象方法进行同步访问，多线程访问同一个对象的synchronized代码块是串行的，访问不同对象是并行的。如果锁住的是类，多线程访问的不管是同一对象还是不同对象的synchronized代码块是都是串行的。

#### 3. synchronized的（底层）原理？

任何一个对象都有一个`monitor`与之相关联，JVM基于进入和退出`mointor`对象来实现代码块同步和方法同步，两者实现细节不同：

- 代码块同步：在编译字节码的时候，代码块起始的地方插入`monitorenter` 指令，异常和代码块结束处插入`monitorexit`指令，线程在执行`monitorenter`指令的时候尝试获取`monitor`对象的所有权，获取不到的情况下就是阻塞
- 方法同步：`synchronized`方法在`method_info`结构有`AAC_synchronized`标记，线程在执行的时候获取对应的锁，从而实现同步方法

#### 4. synchronized和Lock的区别？

主要区别：

1. `synchronized`是Java中的关键字，是Java的内置实现；`Lock`是Java中的接口。
2. `synchronized`遇到异常会释放锁；`Lock`需要在发生异常的时候调用成员方法`Lock#unlock()`方法。
3. `synchronized`是不可以中断的，`Lock`可中断。
4. `synchronized`不能去尝试获得锁，没有获得锁就会被阻塞； `Lock`可以去尝试获得锁，如果未获得可以尝试处理其他逻辑。
5. `synchronized`多线程效率不如`Lock`，不过Java在1.6以后已经对`synchronized`进行大量的优化，所以性能上来讲，其实差不了多少。

#### 5. 悲观锁和乐观锁的举例？以及它们的相关实现？

悲观锁和乐观锁的概念：

- 悲观锁：悲观锁会认为，修改共享数据的时候其他线程也会修改数据，因此只在不会受到其他线程干扰的情况下执行。这样会导致其他有需要锁的线程挂起，等到持有锁的线程释放锁
- 乐观锁：每次不加锁，每次直接修改共享数据假设其他线程不会修改，如果发生冲突就直接重试，直到成功为止

举例：

- `悲观锁`：典型的悲观锁是独占锁，有`synchronized`、`ReentrantLock`。
- `乐观锁`：典型的乐观锁是CAS，实现CAS的`atomic`为代表的一系列类

#### 6. CAS是什么？底层原理？

`CAS`全称Compare And Set，核心的三个元素是：内存位置、预期原值和新值，执行CAS的时候，会将内存位置的值与预期原值进行比较，如果一致，就将原值更新为新值，否则就不更新。 底层原理：是借助CPU底层指令`cmpxchg`实现原子操作。



### 五、ReentranLock
### 六、线程间通信

#### 1. notify和notifyAll方法的区别？

`notify`随机唤醒一个线程，`notifyAll`唤醒所有等待的线程，让他们竞争锁。

#### 2. wait/notify和Condition类实现的等待通知有什么区别？

`synchronized`与`wait/notify`结合的等待通知只有一个条件，而Condition类可以实现多个条件等待。

#### 3. 多线程间的有序性、可见性和原子性是什么意思？

- `原子性`：执行一个或者多个操作的时候，要么全部执行，要么都不执行，并且中间过程中不会被打断。Java中的原子性可以通过独占锁和CAS去保证
- `可见性`：指多线程访问同一个变量的时候，一个线程修改了变量的值，其他线程能够立刻看得到修改的值。锁和`volatile`能够保证可见性
- `有序性`：程序执行的顺序按照代码先后的顺序执行。锁和`volatile`能够保证有序性

#### 4. happens-before原则有哪些？

Java内存模型具有一些先天的有序性，它通常叫做happens-before原则。

如果两个操作的先后顺序不能通过happens-before原则推倒出来，那就不能保证它们的先后执行顺序，虚拟机就可以随意打乱执行指令。`happens-before`原则有：

1. 程序次序规则：单线程程序的执行结果得和看上去代码执行的结果要一致。
2. 锁定规则：一个锁的`lock`操作一定发生在上一个`unlock`操作之后。
3. volatile规则：对`volatile`变量的写操作一定先行于后面对这个变量的对操作。
4. 传递规则：A发生在B前面，B发生在C前面，那么A一定发生在C前面。
5. 线程启动规则：线程的`start`方法先行发生于线程中的每个动作。
6. 线程中断规则：对线程的`interrupt`操作先行发生于中断线程的检测代码。
7. 线程终结原则：线程中所有的操作都先行发生于线程的终止检测。
8. 对象终止原则：一个对象的初始化先行发生于他的`finalize()`方法的执行。

前四条规则比较重要。

### 七、Java内存模型

#### 1. volatile 的作用和原理

**可见性** 如果对声明了`volatile`的变量进行写操作的时候，JVM会向处理器发送一条`Lock`前缀的指令，将这个变量所在缓存行的数据写入到系统内存。

多处理器的环境下，其他处理器的缓存还是旧的，为了保证各个处理器一致，会通过嗅探在总线上传播的数据来检测自己的数据是否过期，如果过期，会强制重新将系统内存的数据读取到处理器缓存。

**有序性** `Lock`前缀的指令相当于一个内存栅栏，它确保指令排序的时候，不会把后面的指令拍到内存栅栏的前面，也不会把前面的指令排到内存栅栏的后面。

#### 2. 一个 int 变量用 volatile 修饰，多线程去操作 i++，是否线程安全？如何保证 i++ 线程安全？AtomicInteger 的底层实现原理？

使用 AtomicInteger 可以使 i++ 线程安全

### 八、阻塞队列

#### 1. 通常的阻塞队列有哪几种，特点是什么？

- `ArrayBlockQueue`：基于数组实现的有界的FIFO(先进先出)阻塞队列。
- `LinkedBlockQueue`：基于链表实现的无界的FIFO(先进先出)阻塞队列。
- `SynchronousQueue`：内部没有任何缓存的阻塞队列。
- `PriorityBlockingQueue`：具有优先级的无限阻塞队列。

#### 2. ConcurrentHashMap的原理

数据结构的实现跟HashMap一样，不做介绍。

JDK 1.8之前采用的是分段锁，核心类是一个`Segment`，`Segment`继承了`ReentrantLock`，每个`Segment对象`管理若干个桶，多个线程访问同一个元素的时候只能去竞争获取锁。

JDK 1.8采用了`CAS + synchronized`，插入键值对的时候如果当前桶中没有Node节点，使用CAS方式进行更新，如果有Node节点，则使用synchronized的方式进行更新。




### 九、其他

## JVM
### 一、Java内存模型

#### 1. Jvm内存区域是如何划分的？

内存区域划分：

- `程序计数器`：当前线程的字节码执行位置的指示器，线程私有。
- `Java虚拟机栈`：描述的Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧，存储着局部变量、操作数栈、动态链接和方法出口等，线程私有。
- `本地方法栈`：本地方法执行的内存模型，线程私有。
- `Java堆`：所有对象实例分配的区域。
- `方法区`：所有已经被虚拟机加载的类的信息、常量、静态变量和即时编辑器编译后的代码数据。

#### 2. Jvm内存模型是怎么样的？

1. Java规定所有变量的内存都需要存储在主内存。

2. 每个线程都有自己的工作内存，线程中使用的所有变量以及对变量的操作都基于工作内存，工作内存中的所有变量都从主内存读取过来的。

3. 不同线程间的工作内存无法进行直接交流，必须通过主内存完成。

   ![Java内存模型](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a70e9f7985?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   主内存和工作内存之间的交互协议，即变量如何从主内存传递到工作内存、工作内存如何将变量传递到主内存，Java内存模型定义了8种操作来完成，并且每一种操作都是原子的，不可再分的。

|   类型   | 说明                                                         |
| :------: | :----------------------------------------------------------- |
|  `lock`  | 作用于主内存的变量，把一个变量标识一个线程独占的状态         |
| `unlock` | 作用于主内存的变量，把一个处于锁定状态的变量释放出来         |
|  `read`  | 把一个变量从主内存传输到工作内存，以便随后的`load`使用       |
|  `load`  | 把`read`操作读取的变量存储到工作内存的变量副本中             |
|  `use`   | 把工作内存中的变量的值传递给执行引擎，每当虚拟机执行到一个需要使用变量的字节码指令的时候都会执行这个操作 |
| `assign` | 把一个从执行引擎中接收到的变量赋值给工作内存中的变量，每当虚拟机遇到赋值的字节码指令都会执行这个操作 |
| `store`  | 把工作内存中的一个变量的值传递给主内存，以便以后的`write`使用 |
| `write`  | 把`store`传递过来的工作内存中的变量写入到主内存中的变量      |

#### 3. String s1 = "abc"和String s2 = new String("abc")的区别，生成对象的情况

1. 指向方法区：`"abc"`是常量，所以它会在方法区中分配内存，如果方法区已经给`"abc"`分配过内存，则s1会直接指向这块内存区域。
2. 指向Java堆：`new String("abc")`是重新生成了一个Java实例，它会在Java堆中分配一块内存。

所以s1和s2的内存地址肯定不一样，但是内容一样。



### 二、类加载器

#### 1. 类加载的过程？

类加载的过程可以分为：

1. `加载`：将类的全限定名转化为二进制流，再将二进制流转化为方法区中的类型信息，从而生成一个Class对象。
2. `验证`：对类的验证，包括格式、字节码、属性等。
3. `准备`：为类变量分配内存并设置初始值。
4. `解析`：将常量池的符号引用转化为直接引用。
5. `初始化`：执行类中定义的Java程序代码，包括类变量的赋值动作和构造函数的赋值。
6. `使用`
7. `卸载`

只有加载、验证、准备、初始化和卸载的这个五个阶段的顺序是确定的。

#### 2. 类加载的机制，以及为什么要这样设计？

类加载的机制是双亲委派模型。大部分Java程序需要使用的类加载器包括：

- `启动类加载器`：由C++语言实现，负责加载Java中的核心类。
- `扩展类加载器`：负责加载Java扩展的核心类之外的类。
- `应用程序类加载器`：负责加载用户类路径上指定的类库。

双亲委派模型如下：

![双亲委派模型](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a726174d8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

双亲委派模型要求出了顶层的启动类加载器之外，其他的类加载器都有自己的父加载器，通过组合实现。



双亲委派模型的工作流程： 当一个类加载的任务来临的时候，先交给父类加载器完成，父类加载器交给父父类加载器完成，知道传递给启动类加载器，如果完成不了的情况下，再依次往下传递类加载的任务。

这样设计的原因： 双亲委派模型能够保证Java程序的稳定运行，不同层次的类加载器具有不同优先级，所有的对象的父类Object，无论哪一个类加载器加载，最后都会交给启动类加载器，保证安全。



### 三、垃圾回收

#### 1. 如何判断对象可回收？

判断一个对象可以回收通常采用的算法是引用几算法和可达性算法。由于互相引用导致的计数不好判断，Java采用的可达性算法。

可达性算法的思路是：通过一些列被成为GC Roots的对象作为起始点，自上往下从这些起点往下搜索，搜索所有走过的路径称为引用链，如果一个对象没有跟任何引用链相关联的时候，则证明该对象不可用，所以这些对象就会被判定为可以回收。

可以被当作GC Roots的对象包括：

- Java虚拟机栈中的引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法中JNI引用的对象

#### 2. GC的常用算法？

- `标记 - 清除`：首先标记出需要回收的对象，标记完成后统一回收所有被标记的对象。容易产生碎片空间。
- `复制算法`：它将可用的内存分为两块，每次只用其中的一块，当需要内存回收的时候，将存活的对象复制到另一块内存，然后将当前已经使用的内存一次性回收掉。需要浪费一半的内存。
- `标记 - 整理`：让存活的对象向一端移动，之后清除边界外的内存。
- `分代搜集`：根据对象存活的周期，Java堆会被分为新生代和老年代，根据不同年代的特性，选择合适的GC收集算法。

#### 3. Minar GC和Full GC的区别？

- `Minar GC`：频率高、针对新生代。
- `Full GC`：频率低、发生在老年代、通常会伴随一次Minar GC和速度慢。

#### 4. 说一下四种引用以及他们的区别？

- `强引用`：强引用还在，垃圾搜集器就不会回收被引用的对象。
- `软引用`：对于软引用关联的对象，在系统发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- `弱引用`：被若引用关联的对象只能存活到下一次GC之前。
- `虚引用`：为对象设置虚引用的目的仅仅是为了GC之前收到一个系统通知。


















#### 