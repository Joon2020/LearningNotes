# 计算机网络操作系统

| 时间       | 版本  | 说明           |
| ---------- | ----- | -------------- |
| 2020.10.15 | 0.0.1 | 初创，结构输入 |
|            |       |                |

## 网络

### 一、网络体系

#### 1. 网页中输入url，到渲染整个界面的整个过程，以及中间用了什么协议？

1）过程分析：主要分为三步

- `DNS解析`。用户输入url后，需要通过DNS解析找到域名对应的ip地址，有了ip地址才能找到服务器端。首先会查找浏览器缓存，是否有对应的dns记录。再继续按照操作系统缓存—路由缓存—isp的dns服务器—根服务器的顺序进行DNS解析，直到找到对应的ip地址。

- `客户端（浏览器）和服务器交互`。浏览器根据解析到的ip地址和端口号发起HTTP请求，请求到达传输层，这里也就是TCP层，开始三次握手建立连接。服务器收到请求后，发送相应报文给客户端（浏览器），客户端收到相应报文并进行解析，得到html页面数据，包括html，js，css等。

- `客户端（浏览器）解析html数据`，构建DOM树，再构造呈现树（render树），最终绘制到浏览器页面上。

2）其中涉及到TCP/IP协议簇，包括DNS，TCP，IP，HTTP协议等等。



### 二、TCP

#### 1. TCP的三次握手过程，为什么需要三次，而不是两次或者四次？



![三次握手](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a755aa564f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

只发送两次，服务端是不知道自己发送的消息能不能被客户端接收到。 因为TCP握手是三次，所以此时双方都已经知道自己发送的消息能够被对方收到，所以，第四次的发送就显得多余了。



#### 2. TCP的四次挥手过程？



![四次挥手](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a7697ec29f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

大致意思就是：



- `Client`：我要断开连接了
- `Server`：我收到你的消息了
- `Server`：我也要断开连接了
- `Client`：收到你要断开连接的消息了

之后`Client`等待两个`MSL`(数据包在网络上生存的最长时间)，如果服务端没有回消息就彻底断开了。

#### 3. TCP和UDP有什么区别？

- `TCP`：基于字节流、面向连接、可靠、能够进行全双工通信，除此以外，还能进行流量控制和拥塞控制，不过效率略低
- `UDP`：基于报文、面向无连接、不可靠，但是传输效率高。

总的来说，TCP适用于传输效率要求低，准确性要求高或要求有连接。而UDP适用于对准确性要求较低，传输效率要求较高的场景，比如语音通话、直播等。

#### 4. TCP为什么是一种可靠的协议？如何做到流量控制和拥塞控制？

- TCP可靠：是因为可以做到数据包发送的有序、无差错和无重复。
- 流量控制：是通过滑动窗口实现的，因为发送发和接收方消息发送速度和接收速度不一定对等，所以需要一个滑动窗口来平衡处理效率，并且保证没有差错和有序的接收数据包。
- 拥塞控制：慢开始和拥塞避免、快重传和快恢复算法。这写算法主要是为了适应网络中的带宽而作出的调整。

#### 5. 具体介绍下TCP/IP

TCP/IP一般指的是TCP/IP协议簇，主要包括了多个不同网络间实现信息传输涉及到的各种协议
主要包括以下几层：

- 应用层：主要提供数据和服务。比如HTTP，FTP，DNS等
- 传输层：负责数据的组装，分块。比如TCP，UDP等
- 网络层：负责告诉通信的目的地，比如IP等
- 数据链路层：负责连接网络的硬件部分，比如以太网，WIFI等

#### 6. TCP的三次握手和四次挥手，为什么不是两次握手？为什么挥手多一次呢？

客户端简称A，服务器端简称B

 1）TCP建立连接需要三次握手

- A向B表示想跟B进行连接（A发送`syn`包，A进入`SYN_SENT`状态）
- B收到消息，表示我也准备好和你连接了（B收到`syn`包，需要确认`syn`包，并且自己也发送一个`syn`包，即发送了`syn+ack`包，B进入`SYN_RECV`状态）
- A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到`syn+ack`包，向服务器发送确认包`ack`，AB进入`established`状态）开始连接。

2）TCP断开连接需要四次挥手

- A向B表示想跟B断开连接（A发送`fin`，进入`FIN_WAIT_1`状态）
- B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入`CLOSE_WAIT`状态）
- 过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入`LAST_ACK`状态）
- A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入`close`d状态）

3）为什么挥手多一次
 其实正常的断开和连接都是需要`四次`：

- A发消息给B
- B反馈给A表示正确收到消息
- B发送消息给A
- A反馈给B表示正确收到消息。

但是连接中，第二步和第三步是`可以合并`的，因为连接之前A和B是无联系的，所以没有其他情况需要处理。而断开的话，因为之前两端是正常连接状态，所以第二步的时候不能保证B之前的消息已经发送完毕，所以不能马上告诉A要断开的消息。这就是连接为什么可以少一步的原因。

4）为什么连接需要三次，而不是两次。
 正常来说，我给你发消息，你告诉我能收到，不就代表我们之前通信是正常的吗？

- 简单回答就是，`TCP是双向通信协议`，如果两次握手，不能保证B发给A的消息正确到达。

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。

TCP是怎么保证可靠传输的？

- `序列号和确认号`。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。

所以握手过程中，比如A发送syn信号给B，初始序列号为120，那么B收到消息，回复`ack`消息，序列号为120+1。同时B发送`syn`信号给A，初始序列号为256，如果收不到A的回复消息，就会重发，否则丢失这个序列号，就无法正常完成后面的通信了。

这就是三次握手的原因。



### 三、UDP



### 四、HTTP（S）

#### 1. 简单介绍下 Https 的原理

#### 2. HTTP是哪一层的协议，常见的HTTP状态码有哪些，分别代表什么意思？

HTTP协议是应用层的协议。

常见的HTTP状态码有：

| 类别  | 解释                                              |
| :---- | :------------------------------------------------ |
| `1xx` | 请求已经接收，继续处理                            |
| `2xx` | 服务器已经正确处理请求，比如`200`                 |
| `3xx` | 重定向，需要做进一步的处理才能完成请求            |
| `4xx` | 服务器无法理解的请求，比如`404`，访问的资源不存在 |
| `5xx` | 服务器收到请求以后，处理错误                      |

#### 3. HTTP 1.1 和HTTP 2有什么区别？

HTTP 2.0基于HTTP 1.1，与HTTP 2.0增加了：

- 二进制格式：HTTP 1.1使用纯文本进行通信，HTTP 2.0使用二进制进行传输。

- Head压缩：对已经发送的Header使用键值建立索引表，相同的Header使用索引表示。

- 服务器推送：服务器可以进行主动推送

- 多路复用：一个TCP连接可以划分成多个流，每个流都会分配Id，客户端可以借助流和服务端建立全双工进行通信，并且流具有优先级。

  ![HTTP2连接](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a74b1f877e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 4. HTTP和HTTPS有什么区别？

简单来说，HTTP和HTTPS的关系是这样的

```
HTTPS = HTTP + SSL/TLS
```

区别如下： HTTP作用于应用层，使用80端口，起始地址是`http://`，明文传输，消息容易被拦截，串改。 HTTPS作用域传输层，使用443端口，起始地址是`https://`，需要下载CA证书，传输的过程需要加密，安全性高。

#### 5. SSL/TLS的握手过程？

这里借用[《趣谈网络协议》](https://time.geekbang.org/column/intro/85)的图片：

![SSL/TLS](https://user-gold-cdn.xitu.io/2020/4/24/171ab7a751550e46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



#### 6. HTTPS传输过程中是如何处理进行加密的？为什么有对称加密的情况下仍然需要进行非对称加密？

过程和上图类似，依次获取证书，公钥，最后生成对称加密的钥匙进行对称加密。

对称加密可以保证加密效率，但是不能解决密钥传输问题；非对称加密可以解决传输问题，但是效率不高。

#### 7. HTTP的几种请求方法具体介绍？PUT和POST区别？

常见的有四种：

- `GET` 获取资源，没有body，幂等性
- `POST` 增加或者修改资源，有body，非幂等性
- `PUT` 修改资源，有body，幂等性
- `DELETE` 删除资源，幂等性

幂等性的方法:如果一个方法重复执行多次，产生的效果是一样的。

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

#### 8. HTTP1.0 HTTP1.1 HTTP1.2有什么区别

#### 9. HTTP请求和响应报文的格式，以及常用状态码

1）请求报文：

```
   //请求行（包括method、path、HTTP版本）
   GET /path HTTP/1.1
   //Headers
   Host: www.baidu.com
   Content-Type: text/plain
   //Body
   搜索****
```

2）响应报文

```
   //状态行 （包括HTTP版本、状态码，状态信息）
   HTTP/1.1 200 OK
   //Headers
   Content-Type: application/json; charset=utf-8
   //Body
   [{"info":"xixi"}]
```

3）常用状态码

主要分为五种类型：

- 1开头， 代表临时性消息，比如100（继续发送）
- 2开头， 代表请求成功，比如200（OK）
- 3开头， 代表重定向，比如304（内容无改变）
- 4开头， 代表客户端的一些错误，比如403（禁止访问）
- 5开头， 代表服务器的一些错误，比如500

#### 10. 介绍对称加密和非对称加密

1）对称加密，即加密和解密算法不同，但是密钥相同。比如`DES，AES`算法。

```kotlin
数据A --> 算法D（密钥S）--> 加密数据B
加密数据B --> 算法E（密钥S）--> 数据A
```

优点：加/解密速度快、密钥管理简单、适宜一对一的信息加密传输，加密算法简单等。
缺点：密钥有可能被破解，容易被伪造。传输过程中一旦密钥被其他人获知则可以进行数据解密。

2）非对称加密，即加密和解密算法相同，但是密钥不同。私钥自己保存，公钥提供给对方。比如`RSA，DSA`算法。

```kotlin
数据A --> 算法D（公钥）--> 加密数据B
加密数据B --> 算法D（私钥）--> 数据A
```

优点：安全，公钥即使被其他人获知，也无法解密数据。
缺点：需要通信双方都有一套公钥和私钥

#### 11. 数字签名的原理

1）首先，为什么需要数字签名？

防止`被攻击，被伪造`。由于公钥是公开的，别人截获到公钥就能伪造数据进行传输，所以我们需要验证数据的来源。

2）怎么签名？
由于公钥能解密私钥加密的数据，所以私钥也能解密公钥加密的数据。（上图非对称加密A和B代号互换即可）
 所以我们用公钥进行加密后，再用私钥进行一次加密，那么私钥的这次加密就叫`签名`，也就是只有我自己可以进行加密的操作。所以传输数据流程就变成了`加密数据和签名数据`，如果解出来都是同样的数据，那么则数据`安全可靠`。

```kotlin
数据A --> 算法D（公钥）--> 加密数据B
数据A --> 算法D（私钥）--> 签名数据C

加密数据B --> 算法D（私钥）--> 数据A
签名数据C --> 算法D（公钥）--> 数据A
```



### 五、Socket



### 六、DNS



## 计算机



## 操作系统

### 概述

### 进程与线程

### 内存管理

### 文件管理