- Java技术提供了以下3种确保安全的机制
  - 语言设计特性
  - 访问控制机制，用于控制代码能够执行的操作
  - 代码签名，代码的作者能够用标准的加密算法来认证Java代码
- 每个Java程序至少拥有三个类加载器：
  - 引导类加载器
  - 扩展类加载器
  - 系统类加载器
- 类加载器之间有一种父子关系，除了引导类加载器外，每个类加载器都有一个父类加载器。只有在父类加载失败的时候，才会加载给定类插件类加载器->系统类 -> 扩展 -> 引导
- 编写自己的类加载器，只需要继承ClassLoader类，然后覆盖findClass(String className) 实现该方法需要做到： 
  - 为来自本地文件系统或者其他来源的类加载其字节码
  - 调用ClassLoader超类的defineClass方法，向虚拟机提供字节码
- 类加载器将新加载的Java平台类的字节码传递给虚拟机时，这些字节码首先要接受校验器的校验
  - 变量要在使用之前进行初始化
  - 方法调用与对象引用类型之间要匹配
  - 访问私有数据和方法的规则没有被违反
  - 对本地变量的访问都落在运行时堆栈内
  - 运行时堆栈没有溢出
- 安全管理器是一个负责控制具体操作是否运行执行的类，检查的操作包括以下内容：
  - 创建一个新的类加载器
  - 退出虚拟机
  - 使用反射访问另一个类的成员
  - 访问本地文件
  - 打开socket连接
  - 启动打印作业
  - 访问系统剪贴板
  - 访问AWT事件队列
  - 打开一个顶层窗口
- 权限类的层次结构

![权限类的层次结构](https://github.com/zhangzhian/LearningNotes/blob/master/res/%E6%9D%83%E9%99%90%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png?raw=true)- 默认情况下，有两个位置可以安装策略文件：
  - Java平台主目录的 java.policy 文件
  - 用户主目录的 .java.policy 文件
- 定制权限，可以继承Permission类，提供以下方法
  - 带有两个String 参数的构造器，这两个参数分别时目标和操作列表
  - String getActions()
  - boolean equals(Object other)
  - int hasCode()
  - boolean implies(Permission other)
- Java认证和授权服务（JAAS）包含两部分：“认证”部分主要负责确定程序使用者的身份，而“授权”将各个用户映射到响应的权限
- 消息摘要是数据快的数字指纹，两个基本属性
  - 如果数据的1位或几位改变了，那么消息也将改变
  - 拥有给定消息的伪造者不能创建与原消息具有相同摘要的假消息 
- MessageDigest 类是用于创建封装了指纹算法的对象的“工厂”，它的静态方法getInstance返回继承了MessageDigest类的某个类的对象，其能承担下面的双重职责
  - 作为一个工厂类
  - 作为所有消息摘要算法的超类
- Cipher类，该类是所有加密算法的超类。通过getInstance方法会活得一个密码对象
- 生成密钥，步骤：
  - 为加密算法获取KeyGenerator
  - 用随机源来初始化密钥发生器
  - 调用generateKey方法 
-  JCE库提供了一组使用便捷的CipherOutputStream/CipherInputStream流类，用于对流数据进行自动加密或解密