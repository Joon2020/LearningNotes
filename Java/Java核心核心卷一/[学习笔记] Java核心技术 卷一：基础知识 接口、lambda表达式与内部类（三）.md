# [学习笔记] Java核心技术 卷一：基础知识 接口、lambda表达式与内部类（三）

---

 - 使用 instanceof检查一个对象是否属于某个特定类一样， 也可以使用 instance 检查一个对象是否实现了某个特定的接口
 - 接口不是类，尤其不能使用 new 运算符实例化一个接口，能声明接口的变量，接口变量必须弓I用实现了接口的类对象
 - 与可以建立类的继承关系一样，接口也可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。
 - 接口中不能包含实例域或静态方法，但却可以包含常量。与接口中的方法都自动地被设置为 public —样，接口中的域将被自动设为 public static final 。
 - 在 Java SE 8 中 ，允许在接口中增加静态方法。理论上讲 ，没有任何理由认为这是不合法的。
 - 可以为接口方法提供一个默认实现。 必须用 default 修饰符标记这样一个方法。在 JavaSE 8 中，这个技术已经过时。现在可以直接在接口中实现方法。
 - 如果先在一个接口中将一个方法定义为默认方法， 然后又在超类或另一个接口中定义了同样的方法：
 - 超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。
 - 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型 （不论是否是默认参数）相同的方法， 必须覆盖这个方法来解决冲突。
 -  lambda 表达式没有参数， 仍然要提供空括号，就像无参数方法一样 
 -  如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。如果方法只有一 参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号
 -  如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，这是不合法的。 例如，（int x)-> { if (x >= 0) return 1; } 就不合法。
 -  表达式 System.out::println 是一个方法引用（ method reference ), 它等价于 lambda 表达式
x 一> System.out.println(x)  
 - 可以在方法引用中使用 this 参数。 例如， this::equals 等同于 x-> this.equals(x)。 使用 super 也是合法的。
 - 构造器引用与方法引用很类似，只不过方法名为 new。例如 ， Person::new 是 Person 构造
器的一个引用。
 - lambda 表达式有 3个部分：
1 ) 一个代码块 ；
2 ) 参数;
3 ) 自由变量的值，这是指非参数而且不在代码中定义的变量。
 -  lambda 表达式可以捕获外围作用域中变量的值。在 Java 中，要确保所捕获的值是明确定义的，这里有一个重要的限制。在 lambda 表达式中 ， 只能引用值不会改变的变量。
 -  内部类（inner class ) 是定义在另一个类中的类。
  -  内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据。
  - 内部类可以对同一个包中的其他类隐藏起来。
  - 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较便捷。
 - 外围类引用的正规语法 `OwterC/ass.this`
 - 在外围类的作用域之外，引用内部类`OuterClass.InnerClass`
 - 内部类中声明的所有静态域都必须是 final。原因很简单。我们希望一个静态域只有一个实例， 不过对于每个外部对象， 会分别有一个单独的内部类实例。如果这个域不是 final, 它可能就不是唯一的
 - 局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。
 

