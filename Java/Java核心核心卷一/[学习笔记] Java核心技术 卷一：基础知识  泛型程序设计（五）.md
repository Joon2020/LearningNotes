# [学习笔记] Java核心技术 卷一：基础知识  泛型程序设计（五）

---

 - 在 **Java SE 7**及以后的版本中， 构造函数中可以省略泛型类型：
`ArrayList<String> files = new ArrayListoO；`
 - 在 Java 库中， 使用变量 E 表示集合的元素类型， K 和 V 分别表示表的关键字与值的类型。 T ( 需要时还可以用临近的字母 U 和 S ) 表示“ 任意类型”。
 - 泛型方法可以定义在普通类中，也可以定义在泛型类中。当调用一个泛型方法时,在方法名前的尖括号中放入具体的类型
 - 对类型变量 T 设置限定（bound) 
 ` public static <T extends Coiparab1e> T a)...`
 - 限定类型用“ &” 分隔，而逗号用来分隔类型变量
 - 需要记住有关 Java 泛型转换的事实 ：
    - 虚拟机中没有泛型，只有普通的类和方法。
    - 所有的类型参数都用它们的限定类型替换。
    - 桥方法被合成来保持多态。
    - 为保持类型安全性，必要时插入强制类型转换。
 - Java 泛型
  - 不能用基本类型实例化类型参数。没有 Pair<double>, 只 有 Pair<Double>。
  -  运行时类型查询只适用于原始类型
  -  不能创建参数化类型的数组，例如：
`Pair<String>[] table = new Pair<String>[10]; // Error`
  - Varargs 警告，可以采用两种方法来抑制这个警告。 一种方法是为调用的方法增加注解` @SuppressWamings("unchecked")` 或者在 Java SE 7中， 还 可 以 用`@SafeVarargs` 直接标注方法
  - 不能实例化类型变量，不能使用像` new T(...， )` 、` new T[...] `或` T.class` 这样的表达式中的类型变量。
  - 不能构造泛型数组
  - 泛型类的静态上下文中类型变量无效，不能在静态域或方法中引用类型变量。
  - 不能在静态域或方法中引用类型变量。
  - 可以消除对受查异常的检查。
  - 当泛型类型被擦除时，无法创建引发冲突的条件。
 - 通配符类型中， 允许类型参数变化。 例如， 通配符类型`Pair<? extends Employee〉`，表示任何泛型 Pair 类型， 它的类型参数是 Employee 的子类
 - 通配符可以指定一个超类型限定 （supertypebound), 如下所亦：`? super Manager`
 - 带有超类型限定的通配符可以向泛型对象写人，带有子类型限定的通配符可以从泛型对象读取 。
 - 无限定的通配符，Pair<?> 和 Pair 本质的不同在于 ： 可以用任意 Object 对象调用原始 Pair 类的 setObject方法

